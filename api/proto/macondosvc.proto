syntax = "proto3";

// GameHistory encodes a whole history of a game, and it should also encode
// the initial board and tile configuration, etc. It can be considered
// to be an instantiation of a GCG file.
message GameHistory {
  repeated GameTurn turns = 1;
  repeated PlayerInfo players = 2;
  int32 version = 3;
  string original_gcg = 4;
  string lexicon = 5;
  string id_auth = 6;
  string uid = 7;
  string title = 8;
  string description = 9;
  // last_known_racks should only be set in an incomplete / in-progress game.
  // if set, player racks should be set to these values.
  repeated string last_known_racks = 10;
  // Add letter distribution (basically game name), board config, and more
  // in the future.
}

// A GamePosition is a single turn of a GameHistory, and contains the state
// associated with that turn. However, a GameHistory does not contain an
// array of GamePosition. It instead contains an array of GameTurn; such
// an array can be used to instantiate GamePositions for every turn.
// message GamePosition {
//   // onturn is NOT the player number that is in `players`, but it is the
//   // INDEX into the players array.
//   int32 onturn = 1;
//   int32 turnnum = 2;
//   bool playing = 3;
//   int32 scoreless_turns = 4;
//   repeated PlayerState players = 5;
// }

// This should be merged into Move.
message GameEvent {
  enum Type {
    TILE_PLACEMENT_MOVE = 0;
    PHONY_TILES_RETURNED = 1;
    PASS = 2;
    CHALLENGE_BONUS = 3;
    EXCHANGE = 4;
    END_RACK_PTS = 5;
    TIME_PENALTY = 6;
    // Only for international rules (or after 6 zeroes)
    END_RACK_PENALTY = 7;
  }

  enum Direction {
    HORIZONTAL = 0;
    VERTICAL = 1;
  }
  string nickname = 1;
  string note = 2;
  string rack = 3;
  Type type = 4;
  int32 cumulative = 5;
  int32 row = 6;
  int32 column = 7;
  Direction direction = 8;
  string position = 9;
  string played_tiles = 10;
  // An event will not have all of these; it depends on the type of the event.
  string exchanged = 11;
  int32 score = 12;
  int32 bonus = 13;
  int32 end_rack_points = 14;
  int32 lost_score = 15;

  bool is_bingo = 16;
}

message GameTurn { repeated GameEvent events = 1; }

message PlayerInfo {
  string nickname = 1;
  string real_name = 2;
}

// message PlayerState {
//   PlayerInfo info = 1;
//   int32 score = 2;
//   string rack_letters = 3;
// }

message SetRackRequest {
  string game_uuid = 1;
  int32 turnnum = 2;
  string rack_letters = 3;
}

message NewGameRequest {
  repeated PlayerInfo players = 1;
  repeated string board_layout = 2;
  string lexicon = 3;
  string letter_distribution = 4;
  // Perhaps an eventual protobuf field that contains a custom letter
  // distribution, as the above should just be a name ("english", etc).
}

message LoadGCGRequest { string gcg = 1; }

message GenMovesRequest {
  string game_uuid = 1;
  int32 turnnum = 2;
  int32 num_moves = 3;
}
message MoveList { repeated GameEvent moves = 1; }

message MoveStatistic {
  double mean = 1;
  double stdev = 2;
  double total_samples = 3;
}

message SimulatedMove {
  GameEvent move = 1;
  // Per-ply statistics
  repeated MoveStatistic score_stats = 2;
  repeated MoveStatistic bingo_stats = 3;
  // Per-simulation statistics
  // Equity =  spread_stats + leftover_stats + any board consideration?
  MoveStatistic spread_stats = 4;
  MoveStatistic leftover_stats = 5;
  MoveStatistic equity_stats = 6;
  MoveStatistic win_stats = 7;
}

message SimulateMovesRequest {
  string game_uuid = 1;
  int32 turnnum = 2;
  repeated GameEvent moves = 3;
  int32 cores = 4;
  int32 plies = 5;
}
// Only one simulation can be going on at any given time. This will probably
// still be the case if I expose that in a multiplayer server, although
// the way simulation will work there is likely to be in-browser (Emscripten
// style) or something similar. So there's no need to provide a simulation ID.
message StopSimulationRequest {}

message SimulateAcknowledgement {}

message GetSimStatsRequest {}

message SimStatsResponse { repeated SimulatedMove moves = 1; }

// AnnotatedGameViewer is a service that will have access to annotated games,
// and can examine positions. It can also step through positions, overwrite
// positions, simulate specific turns, generate moves, and more.
service GameAnnotationService {
  rpc NewGame(NewGameRequest) returns (GameHistory);

  rpc LoadGCG(LoadGCGRequest) returns (GameHistory);

  // Functions such as stepping forward, stepping backwards, going to a
  // specific turn should be handled only by the front-end. This is because
  // GameHistory has all the info necessary to reconstruct this state.
  // (Or at least, they shouldn't be RPC calls. They can just modify the
  //  GamePosition accordingly)

  // SetRack sets the rack for a specific game position and returns an all
  // new GameHistory.
  rpc SetRack(SetRackRequest) returns (GameHistory);

  rpc GenerateMoves(GenMovesRequest) returns (GameEvent);

  rpc SimulateMoves(SimulateMovesRequest) returns (SimulateAcknowledgement);

  rpc StopSimulation(StopSimulationRequest) returns (SimStatsResponse);

  rpc GetSimulationStats(GetSimStatsRequest) returns (SimStatsResponse);
}
