package cross_set

import (
	"github.com/domino14/macondo/alphabet"
	"github.com/domino14/macondo/board"
	"github.com/domino14/macondo/gaddag"
	"github.com/domino14/macondo/gaddagmaker"
	"github.com/domino14/macondo/move"
)

type CrossSet = board.CrossSet
type Board = board.GameBoard

const (
	Left       = board.LeftDirection
	Right      = board.RightDirection
	Horizontal = board.HorizontalDirection
	Vertical   = board.VerticalDirection
)

type Generator interface {
	GenCrossSet(b *Board, row int, col int, dir board.BoardDirection)
	GenAllCrossSets(b *Board)
	UpdateCrossSetsForMove(b *Board, m *move.Move)
}

// ----------------------------------------------------------------------
// Use a CrossScoreOnlyGenerator when you don't need cross sets

type CrossScoreOnlyGenerator struct {
	Dist *alphabet.LetterDistribution
}

func (g CrossScoreOnlyGenerator) GenCrossSet(b *Board, row int, col int, dir board.BoardDirection) {
	genCrossScore(b, row, col, dir, g.Dist)
}

func (g CrossScoreOnlyGenerator) GenAllCrossSets(b *Board) {
	GenAllCrossScores(b, g.Dist)
}

func (g CrossScoreOnlyGenerator) UpdateCrossSetsForMove(b *Board, m *move.Move) {
	updateCrossScoresForMove(b, m, g.Dist)
}

func genCrossScore(b *Board, row int, col int, dir board.BoardDirection,
	ld *alphabet.LetterDistribution) {
	if row < 0 || row >= b.Dim() || col < 0 || col >= b.Dim() {
		return
	}
	// If the square has a letter in it, its cross set and cross score
	// should both be 0
	if !b.GetSquare(row, col).IsEmpty() {
		b.GetSquare(row, col).SetCrossScore(0, dir)
		return
	}
	// If there's no tile adjacent to this square in any direction,
	// every letter is allowed.
	if b.LeftAndRightEmpty(row, col) {
		b.GetSquare(row, col).SetCrossScore(0, dir)
		return
	}
	// If we are here, there is a letter to the left, to the right, or both.
	// start from the right and go backwards.
	rightCol := b.WordEdge(row, col+1, Right)
	if rightCol == col {
		score := b.TraverseBackwardsForScore(row, col-1, ld)
		b.GetSquare(row, col).SetCrossScore(score, dir)
	} else {
		// Otherwise, the right is not empty. Check if the left is empty,
		// if so we just traverse right, otherwise, we try every letter.
		scoreR := b.TraverseBackwardsForScore(row, rightCol, ld)
		scoreL := b.TraverseBackwardsForScore(row, col-1, ld)
		b.GetSquare(row, col).SetCrossScore(scoreR+scoreL, dir)
	}
}

// TODO: Make this take a generator as an argument and merge with GenAllCrossSets
func GenAllCrossScores(b *Board, ld *alphabet.LetterDistribution) {
	n := b.Dim()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			genCrossScore(b, i, j, Horizontal, ld)
		}
	}
	b.Transpose()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			genCrossScore(b, i, j, Vertical, ld)
		}
	}
	// And transpose back to the original orientation.
	b.Transpose()
}

// TODO: Merge with UpdateCrossSetsForMove
func updateCrossScoresForMove(b *Board, m *move.Move, ld *alphabet.LetterDistribution) {
	row, col, vertical := m.CoordsAndVertical()
	// Every tile placed by this new move creates new "across" words, and we need
	// to update the cross sets on both sides of these across words, as well
	// as the cross sets for THIS word.

	// Assumes all across words are HORIZONTAL.
	calcForAcross := func(rowStart int, colStart int, csd board.BoardDirection) {
		for row := rowStart; row < len(m.Tiles())+rowStart; row++ {
			if m.Tiles()[row-rowStart] == alphabet.PlayedThroughMarker {
				// No new "across word" was generated by this tile, so no need
				// to update cross set.
				continue
			}
			// Otherwise, look along this row. Note, the edge is still part
			// of the word.
			rightCol := b.WordEdge(int(row), int(colStart), Right)
			leftCol := b.WordEdge(int(row), int(colStart), Left)
			genCrossScore(b, int(row), int(rightCol)+1, csd, ld)
			genCrossScore(b, int(row), int(leftCol)-1, csd, ld)
			// This should clear the cross set on the just played tile.
			genCrossScore(b, int(row), int(colStart), csd, ld)
		}
	}

	// assumes self is HORIZONTAL
	calcForSelf := func(rowStart int, colStart int, csd board.BoardDirection) {
		// Generate cross-sets on either side of the word.
		for col := int(colStart) - 1; col <= int(colStart)+len(m.Tiles()); col++ {
			genCrossScore(b, int(rowStart), col, csd, ld)
		}
	}

	if vertical {
		calcForAcross(row, col, Horizontal)
		b.Transpose()
		row, col = col, row
		calcForSelf(row, col, Vertical)
		b.Transpose()
	} else {
		calcForSelf(row, col, Horizontal)
		b.Transpose()
		row, col = col, row
		calcForAcross(row, col, Vertical)
		b.Transpose()
	}
}

// ----------------------------------------------------------------------
// GaddagCrossSetGenerator generates cross sets via a gaddag

type GaddagCrossSetGenerator struct {
	Gaddag gaddag.GenericDawg
	Dist   *alphabet.LetterDistribution
}

func (g GaddagCrossSetGenerator) GenCrossSet(b *Board, row int, col int, dir board.BoardDirection) {
	GenCrossSet(b, row, col, dir, g.Gaddag, g.Dist)
}

func (g GaddagCrossSetGenerator) GenAllCrossSets(b *Board) {
	GenAllCrossSets(b, g.Gaddag, g.Dist)
}

func (g GaddagCrossSetGenerator) UpdateCrossSetsForMove(b *Board, m *move.Move) {
	UpdateCrossSetsForMove(b, m, g.Gaddag, g.Dist)
}

// ----------------------------------------------------------------------
// Implementation for GaddagCrossSetGenerator

func traverseBackwards(b *Board, row int, col int,
	nodeIdx uint32, checkLetterSet bool, leftMostCol int,
	gaddag gaddag.GenericDawg) (uint32, bool) {
	// Traverse the letters on the board backwards (left). Return the index
	// of the node in the gaddag for the left-most letter, and a boolean
	// indicating if the gaddag path was valid.
	// If checkLetterSet is true, then we traverse until leftMostCol+1 and
	// check the letter set of this node to see if it includes the letter
	// at leftMostCol
	for b.PosExists(row, col) {
		ml := b.GetSquare(row, col).Letter()
		if ml == alphabet.EmptySquareMarker {
			break
		}

		if checkLetterSet && col == leftMostCol {
			if gaddag.InLetterSet(ml, nodeIdx) {
				return nodeIdx, true
			}
			// Give up early; if we're checking letter sets we only care about
			// this column.
			return nodeIdx, false
		}

		nodeIdx = gaddag.NextNodeIdx(nodeIdx, ml.Unblank())
		if nodeIdx == 0 {
			// There is no path in the gaddag for this word part; this
			// can occur if a phony was played and stayed on the board
			// and the phony has no extensions for example, or if it's
			// a real word with no further extensions.
			return nodeIdx, false
		}

		col--
	}

	return nodeIdx, true
}

func UpdateCrossSetsForMove(b *Board, m *move.Move,
	gd gaddag.GenericDawg, ld *alphabet.LetterDistribution) {

	row, col, vertical := m.CoordsAndVertical()
	// Every tile placed by this new move creates new "across" words, and we need
	// to update the cross sets on both sides of these across words, as well
	// as the cross sets for THIS word.

	// Assumes all across words are HORIZONTAL.
	calcForAcross := func(rowStart int, colStart int, csd board.BoardDirection) {
		for row := rowStart; row < len(m.Tiles())+rowStart; row++ {
			if m.Tiles()[row-rowStart] == alphabet.PlayedThroughMarker {
				// No new "across word" was generated by this tile, so no need
				// to update cross set.
				continue
			}
			// Otherwise, look along this row. Note, the edge is still part
			// of the word.
			rightCol := b.WordEdge(int(row), int(colStart), Right)
			leftCol := b.WordEdge(int(row), int(colStart), Left)
			GenCrossSet(b, int(row), int(rightCol)+1, csd, gd, ld)
			GenCrossSet(b, int(row), int(leftCol)-1, csd, gd, ld)
			// This should clear the cross set on the just played tile.
			GenCrossSet(b, int(row), int(colStart), csd, gd, ld)
		}
	}

	// assumes self is HORIZONTAL
	calcForSelf := func(rowStart int, colStart int, csd board.BoardDirection) {
		// Generate cross-sets on either side of the word.
		for col := int(colStart) - 1; col <= int(colStart)+len(m.Tiles()); col++ {
			GenCrossSet(b, int(rowStart), col, csd, gd, ld)
		}
	}

	if vertical {
		calcForAcross(row, col, Horizontal)
		b.Transpose()
		row, col = col, row
		calcForSelf(row, col, Vertical)
		b.Transpose()
	} else {
		calcForSelf(row, col, Horizontal)
		b.Transpose()
		row, col = col, row
		calcForAcross(row, col, Vertical)
		b.Transpose()
	}

}

// GenAllCrossSets generates all cross-sets. It goes through the entire
// board; our anchor algorithm doesn't quite match the one in the Gordon
// paper.
// We do this for both transpositions of the board.
func GenAllCrossSets(b *Board, gaddag gaddag.GenericDawg, ld *alphabet.LetterDistribution) {

	n := b.Dim()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			GenCrossSet(b, i, j, Horizontal, gaddag, ld)
		}
	}
	b.Transpose()
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			GenCrossSet(b, i, j, Vertical, gaddag, ld)
		}
	}
	// And transpose back to the original orientation.
	b.Transpose()
}

// GenCrossSet generates a cross-set for each individual square.
func GenCrossSet(b *Board, row int, col int, dir board.BoardDirection,
	gaddag gaddag.GenericDawg, ld *alphabet.LetterDistribution) {

	if row < 0 || row >= b.Dim() || col < 0 || col >= b.Dim() {
		return
	}
	// If the square has a letter in it, its cross set and cross score
	// should both be 0
	if !b.GetSquare(row, col).IsEmpty() {
		b.GetSquare(row, col).SetCrossSet(CrossSet(0), dir)
		b.GetSquare(row, col).SetCrossScore(0, dir)
		return
	}
	// If there's no tile adjacent to this square in any direction,
	// every letter is allowed.
	if b.LeftAndRightEmpty(row, col) {
		b.GetSquare(row, col).SetCrossSet(board.TrivialCrossSet, dir)
		b.GetSquare(row, col).SetCrossScore(0, dir)

		return
	}
	// If we are here, there is a letter to the left, to the right, or both.
	// start from the right and go backwards.
	rightCol := b.WordEdge(row, col+1, Right)
	if rightCol == col {
		// This means the right was always empty; we only want to go left.
		lNodeIdx, lPathValid := traverseBackwards(b, row, col-1,
			gaddag.GetRootNodeIndex(), false, 0, gaddag)
		score := b.TraverseBackwardsForScore(row, col-1, ld)
		b.GetSquare(row, col).SetCrossScore(score, dir)

		if !lPathValid {
			// There are no further extensions to the word on the board,
			// which may also be a phony.
			b.GetSquare(row, col).SetCrossSet(CrossSet(0), dir)
			return
		}
		// Otherwise, we have a left node index.
		sIdx := gaddag.NextNodeIdx(lNodeIdx, alphabet.SeparationMachineLetter)
		// Take the letter set of this sIdx as the cross-set.
		letterSet := gaddag.GetLetterSet(sIdx)
		// Miraculously, letter sets and cross sets are compatible.
		b.GetSquare(row, col).SetCrossSet(CrossSet(letterSet), dir)
	} else {

		// Otherwise, the right is not empty. Check if the left is empty,
		// if so we just traverse right, otherwise, we try every letter.
		leftCol := b.WordEdge(row, col-1, Left)
		// Start at the right col and work back to this square.
		lNodeIdx, lPathValid := traverseBackwards(b, row, rightCol,
			gaddag.GetRootNodeIndex(), false, 0, gaddag)
		scoreR := b.TraverseBackwardsForScore(row, rightCol, ld)
		scoreL := b.TraverseBackwardsForScore(row, col-1, ld)
		b.GetSquare(row, col).SetCrossScore(scoreR+scoreL, dir)
		if !lPathValid {
			b.GetSquare(row, col).SetCrossSet(CrossSet(0), dir)
			return
		}
		if leftCol == col {
			// The left is empty, but the right isn't.
			// The cross-set is just the letter set of the letter directly
			// to our right.

			letterSet := gaddag.GetLetterSet(lNodeIdx)
			b.GetSquare(row, col).SetCrossSet(CrossSet(letterSet), dir)
		} else {
			// Both the left and the right have a tile. Go through the
			// siblings, from the right, to see what nodes lead to the left.

			numArcs := gaddag.NumArcs(lNodeIdx)
			crossSet := b.GetSquare(row, col).GetCrossSet(dir)
			*crossSet = CrossSet(0)
			for i := lNodeIdx + 1; i <= uint32(numArcs)+lNodeIdx; i++ {
				ml := alphabet.MachineLetter(gaddag.Nodes()[i] >>
					gaddagmaker.LetterBitLoc)
				if ml == alphabet.SeparationMachineLetter {
					continue
				}
				nnIdx := gaddag.Nodes()[i] & gaddagmaker.NodeIdxBitMask
				_, success := traverseBackwards(b, row, col-1, nnIdx, true,
					leftCol, gaddag)
				if success {
					crossSet.Set(ml)
				}
			}
		}
	}
}
